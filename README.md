# Алгоритми для підрахунку монет

Даний модуль містить два алгоритми для розрахунку мінімальної кількості монет, які складають задану суму:

1. **Жадібний алгоритм**
2. **Алгоритм динамічного програмування**

## Приклади використання

Для суми **113** обидва алгоритми — жадібний та динамічного програмування — повернули однаковий результат:

- **Жадібний алгоритм:** `{50: 2, 10: 1, 2: 1, 1: 1}`
- **Алгоритм динамічного програмування:** `{50: 2, 10: 1, 2: 1, 1: 1}`

## Порівняння алгоритмів

### 1. Жадібний алгоритм
- **Складність:** \(O(n)\), де \(n\) — кількість номіналів монет.
- **Переваги:** Простий у реалізації та швидкий на практиці. Повертає оптимальний результат для добре підібраних наборів монет.
- **Недоліки:** Може не дати оптимального результату для всіх можливих наборів. Наприклад, для монет [9, 6, 1] цей алгоритм може повернути неоптимальний розподіл.

### 2. Алгоритм динамічного програмування
- **Складність:** \(O(n \cdot m)\), де \(n\) — кількість номіналів монет, а \(m\) — сума, для якої шукається рішення.
- **Переваги:** Гарантує мінімальну кількість монет для будь-якого набору номіналів.
- **Недоліки:** Вимагає більше пам'яті та часу для обчислень, особливо при великих значеннях суми.

## Результати

- **Жадібний алгоритм** — ефективний для практичного використання зі стандартними наборами монет.
- **Алгоритм динамічного програмування** — забезпечує мінімальну кількість монет навіть для нестандартних випадків.

## Рекомендації
- Для касових апаратів зі стандартними наборами монет жадібний алгоритм є більш практичним, оскільки він швидший і менш ресурсозатратний.
- Для загальних випадків, коли набір монет може бути довільним, краще використовувати алгоритм динамічного програмування, оскільки він гарантує оптимальний розподіл.

